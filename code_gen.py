import os, json, re, tempfile, subprocess
from typing import List, TypedDict, Dict, Any, Optional
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_community.llms.huggingface_endpoint import HuggingFaceEndpoint
from langchain_community.vectorstores import Chroma
from langchain_community.graphs import Neo4jGraph
from langchain_community.chains import GraphCypherQAChain
from langchain.prompts import PromptTemplate
from langchain_core.documents import Document 
from langchain_core.pydantic_v1 import BaseModel, Field
from langgraph.graph import StateGraph, END, START
from langgraph.checkpoint.memory import MemorySaver

EMBEDDING_MODEL="sentence-transformers/all-mpnet-base-v2"
CHROMA_PERSIST_DIRECTORY="chroma_db"
CHROMA_COLLECTION_NAME="embed_storage"

NEO4J_URI=os.getenv('NEO4J_URI')
NEO4J_USERNAME=os.getenv('NEO4J_USERNAME')
NEO4J_PASSWORD=os.getenv('NEO4J_PASSWORD')

HUGGING_FACEHUB_MODEL="meta-llama/Llama-3.1-8b-instruct"
HGFC_API_TOKEN=os.getenv("HUGGINGFACEHUB_API_TOKEN")

class ResearchExperiment(BaseModel):
    """
    Represents a Python code snippet for a research experiment.
    """
    code_snippet: str=Field(description="A complete and runnable Python code snippet for the experiment.")
    justification: str=Field(description="Brief explanation of the experiment's purpose, its connection to the provided context, and what it aims to test.")
    dependencies: List[str]=Field(description="List of Python libraries required to run the code (e.g., ['numpy', 'scikit-learn']).")
    test_case: str=Field(description="A simple, illustrative test case or input data to verify the code snippet's functionality.")

embedding_function=HuggingFaceEmbeddings(model_name=EMBEDDING_MODEL)

vectordb=Chroma(collection_name=CHROMA_COLLECTION_NAME,embedding_function=embedding_function,persist_directory=CHROMA_PERSIST_DIRECTORY)

llm=HuggingFaceEndpoint(
    repo_id=HUGGING_FACEHUB_MODEL,
    temperature=0.7,
    max_new_tokens=512,
    huggingfacehub_api_token=HGFC_API_TOKEN
)

graph=Neo4jGraph(url=NEO4J_URI,username=NEO4J_USERNAME,password=NEO4J_PASSWORD)
graph.refresh_schema()

class GraphState(TypedDict):
    """
    question: The user's query.
    vector_docs: List of documents retrieved from the vector database.
    graph_result: Structured data retrieved from the graph database.
    final_answer: The final answer generated by the LLM.
    messages: A list of messages to maintain conversation history (optional).
    """
    question: str
    vector_docs: List[Document]
    graph_result: str|dict
    final_answer: str

def retrieve_from_vector_db(state: GraphState)->GraphState:
    focus_area=state["focus_area"]
    retriever= vectordb.as_retriever(search_kwargs={"k": 10})
    vector_docs=retriever.invoke(focus_area)
    return {"vector_docs": vector_docs}

def query_neo4j_graph(state: GraphState)->GraphState:
    focus_area=state["focus_area"]
    graph_qa_chain=GraphCypherQAChain.from_llm(llm=llm,graph=graph,verbose=True)
    query_for_graph=f"What are the indirect and direct relationships between '{focus_area}' and research methods, concepts, or influential authors that could support hypothesis generation?"
    graph_result=graph_qa_chain.invoke({"query": query_for_graph})
    return {"graph_result": graph_result}

def generate_experiment_code(state: GraphState)->GraphState:
    focus_area=state["focus_area"]
    vector_db=state["vector_docs"]
    graph_result=state["graph_result"]

    vector_context="\n\n".join([doc.page_content for doc in vector_db])
    context=f"Vector Database Context:\n{vector_context}\n\nGraph Database Context:\n{graph_result}"

    prompt="""
    You are an expert AI programmer and researcher. Your task is to generate a Python code snippet for a research experiment.
    The experiment should be based on the provided research paper contexts (Vector Database Context and Graph Database Context).
    Focus on implementing a specific method or testing a hypothesis from the context.

    Your output MUST be a JSON object that strictly adheres to the following Pydantic schema:
    ```json
    {{
        "code_snippet": "string",
        "justification": "string",
        "dependencies": ["string"],
        "test_case": "string"
    }}
    ```
    Ensure the code is a single, complete block of Python code, including necessary imports.
    Populate all fields based on the context, or state "N/A" if no information is available.
    
    Focus Area: {focus_area}
    
    Combined Research Context:
    {full_context}
    
    Generate the experiment code in JSON format:
"""
    prompt_template=PromptTemplate(
        input_variables=["focus_area", "full_context"],
        template=prompt
    )
    json_chain=prompt_template | llm
    json_output=json_chain.invoke({"focus_area":focus_area,"full_context":context}).content
    json_match=re.search(r"```json\n(.*)\n```",json_output,re.DOTALL)
    json_string=json_match.group(1) if json_match else json_output
    parsed_code=json.loads(json_string)
    return {"code": parsed_code}

code_workflow = StateGraph(GraphState)
code_workflow.add_node("retrieve_vector_docs", retrieve_from_vector_db)
code_workflow.add_node("query_neo4j_graph", query_neo4j_graph)
code_workflow.add_node("generate_experiment_code", generate_experiment_code)
code_workflow.add_edge(START, "retrieve_vector_docs")
code_workflow.add_edge("retrieve_vector_docs", "query_neo4j_graph")
code_workflow.add_edge("query_neo4j_graph", "generate_experiment_code")
code_workflow.add_edge("generate_experiment_code", END)
code_app = code_workflow.compile(checkpointer=MemorySaver())

def test_code_gend(code_snippet: str, timeout_seconds: int = 60)->dict:
    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as temp_file:
        temp_file.write(code_snippet)
        temp_file_path=temp_file.name
    try:
        result=subprocess.run(['python', temp_file_path], capture_output=True, text=True, timeout=timeout_seconds, check=True)
        stdout=result.stdout; stderr=result.stderr; exit_code=result.returncode; success=True
    except subprocess.CalledProcessError as e:
        stdout=e.stdout; stderr=e.stderr; exit_code=e.returncode; success=False
    except subprocess.TimeoutExpired:
        stdout="Execution timed out."; stderr="Execution timed out."; exit_code=1; success=False
    except FileNotFoundError:
        stdout=""; stderr="Python interpreter not found."; exit_code=1; success=False
    finally:
        os.remove(temp_file_path)
    return {"stdout": stdout, "stderr": stderr, "exit_code": exit_code, "success": success}

if __name__ == "__main__":
    print("\n--- Starting PaperForge Code Generation & Testing Pipeline ---")
    while True:
        focus_area_text = input("\nEnter a focus area for experiment code (type 'exit' to quit): ").strip()
        if focus_area_text.lower() == 'exit':
            break
        print("\n--- Step 1: Generating Code Snippet... ---")
        final_state = None
        for s in code_app.stream({"focus_area": focus_area_text}):
            final_state = s
        
        generated_code_json=final_state[list(final_state.keys())[-1]]["code"]
        code_to_test = generated_code_json.get("code_snippet", "")
        
        if not code_to_test or "error" in generated_code_json:
            print("Code generation failed or returned invalid JSON. Please try a different query.")
            if "error" in generated_code_json: print(f"Error: {generated_code_json['error']}"); print(f"Raw Output: {generated_code_json['raw_output']}")
            continue

        print("\n--- Code Generated Successfully ---")
        print("Snippet:")
        print(generated_code_json["code_snippet"])
        print("-" * 20)
        
        print("\n--- Step 2: Running Test Harness... ---")
        execution_results = test_code_gend(code_to_test)
        
        print("\n--- Step 3: Code Execution Results ---")
        print(f"Success: {execution_results['success']}")
        print(f"Exit Code: {execution_results['exit_code']}")
        print("\nStandard Output (stdout):")
        print("-------------------------")
        print(execution_results['stdout'])
        print("\nStandard Error (stderr):")
        print("-------------------------")
        print(execution_results['stderr'])
        print("-------------------------")

    print("\n--- PaperForge Pipeline Complete. Exiting. ---")